||| WASM Builder for ICP Canisters
|||
||| Idris2 library for building IC-compatible WASM:
||| Idris2 (.idr) → RefC → C → Emscripten → WASM → WASI stub
|||
||| This module provides the build pipeline that was previously
||| implemented in build-canister.sh scripts.
module WasmBuilder.WasmBuilder

import Data.String
import Data.List
import System
import System.File
import WasmBuilder.SourceMap.SourceMap
import WasmBuilder.SourceMap.VLQ

%default covering

-- =============================================================================
-- Types
-- =============================================================================

||| Build options for WASM compilation
public export
record BuildOptions where
  constructor MkBuildOptions
  projectDir : String      -- Project root directory
  canisterName : String    -- Canister name (for output naming)
  mainModule : String      -- Main module path (default: src/Main.idr)
  packages : List String   -- Additional packages (-p flags)
  generateSourceMap : Bool -- Generate Idris→WASM source map

||| Default build options
public export
defaultBuildOptions : BuildOptions
defaultBuildOptions = MkBuildOptions
  { projectDir = "."
  , canisterName = "canister"
  , mainModule = "src/Main.idr"
  , packages = ["contrib"]
  , generateSourceMap = True
  }

||| Build result
public export
data BuildResult
  = BuildSuccess String   -- Success with WASM path
  | BuildError String     -- Build failed with error

public export
Show BuildResult where
  show (BuildSuccess path) = "Built: " ++ path
  show (BuildError err) = "Build error: " ++ err

||| Check if build succeeded
public export
isSuccess : BuildResult -> Bool
isSuccess (BuildSuccess _) = True
isSuccess (BuildError _) = False

-- =============================================================================
-- Shell Execution
-- =============================================================================

||| Execute a shell command and capture output
executeCommand : String -> IO (Int, String, String)
executeCommand cmd = do
  let stdoutFile = "/tmp/wasm_build_stdout_" ++ show !time ++ ".txt"
  let stderrFile = "/tmp/wasm_build_stderr_" ++ show !time ++ ".txt"
  let fullCmd = cmd ++ " > " ++ stdoutFile ++ " 2> " ++ stderrFile

  exitCode <- system fullCmd

  Right stdout <- readFile stdoutFile
    | Left _ => pure (exitCode, "", "")
  Right stderr <- readFile stderrFile
    | Left _ => pure (exitCode, stdout, "")

  _ <- system $ "rm -f " ++ stdoutFile ++ " " ++ stderrFile

  pure (exitCode, trim stdout, trim stderr)

-- =============================================================================
-- Build Pipeline Steps
-- =============================================================================

||| Step 1: Compile Idris2 to C using RefC backend
|||
||| @opts Build options
||| @buildDir Output directory for C files
||| Returns path to generated C file on success
||| Find ipkg file in project directory
findIpkg : String -> IO (Maybe String)
findIpkg projectDir = do
  (_, result, _) <- executeCommand $ "find " ++ projectDir ++ " -maxdepth 1 -name '*.ipkg' | head -1"
  pure $ if null (trim result) then Nothing else Just (trim result)

public export
compileToRefC : BuildOptions -> String -> IO (Either String String)
compileToRefC opts buildDir = do
  putStrLn "      Step 1: Idris2 → C (RefC backend)"

  -- Try to find ipkg file for proper dependency resolution
  Just ipkgFile <- findIpkg opts.projectDir
    | Nothing => do
        putStrLn "        No .ipkg file found, using direct compilation"
        compileDirectly opts buildDir

  let ipkgName = ipkgFile
  let cmd = "cd " ++ opts.projectDir ++ " && " ++
            "idris2 --codegen refc --build " ++ ipkgName

  -- RefC generates C file then tries native compile (which fails without GMP)
  -- We ignore the exit code and just check if C file was generated
  _ <- executeCommand cmd

  -- Find generated C file in project's build directory
  let findCmd = "sh -c 'find " ++ opts.projectDir ++ "/build -name \"*.c\" 2>/dev/null | head -1'"
  (_, cFile, _) <- executeCommand findCmd
  if null (trim cFile)
    then pure $ Left "No C file generated by RefC"
    else do
      putStrLn $ "        Generated: " ++ trim cFile
      pure $ Right (trim cFile)
  where
    compileDirectly : BuildOptions -> String -> IO (Either String String)
    compileDirectly opts' buildDir' = do
      let pkgFlags = unwords $ map (\p => "-p " ++ p) opts'.packages
      let cmd = "cd " ++ opts'.projectDir ++ " && " ++
                "mkdir -p " ++ buildDir' ++ " && " ++
                "idris2 --codegen refc " ++
                "--build-dir " ++ buildDir' ++ " " ++
                pkgFlags ++ " " ++
                "--source-dir src " ++
                "-o main " ++
                opts'.mainModule
      _ <- executeCommand cmd
      let findCmd = "sh -c 'find " ++ buildDir' ++ " -name \"*.c\" 2>/dev/null | head -1'"
      (_, cFile, _) <- executeCommand findCmd
      if null (trim cFile)
        then pure $ Left "No C file generated by RefC"
        else do
          putStrLn $ "        Generated: " ++ trim cFile
          pure $ Right (trim cFile)

||| Step 2: Download/locate RefC runtime dependencies
|||
||| Returns (refcSrcDir, miniGmpDir)
public export
prepareRefCRuntime : IO (Either String (String, String))
prepareRefCRuntime = do
  putStrLn "      Step 2: Preparing RefC runtime"

  let refcSrc = "/tmp/refc-src"
  let miniGmp = "/tmp/mini-gmp"

  -- Check if already downloaded
  Right _ <- readFile (refcSrc ++ "/runtime.c")
    | Left _ => downloadRuntime refcSrc miniGmp

  Right _ <- readFile (miniGmp ++ "/mini-gmp.c")
    | Left _ => downloadRuntime refcSrc miniGmp

  putStrLn "        Runtime ready"
  pure $ Right (refcSrc, miniGmp)
  where
    gmpWrapper : String
    gmpWrapper = "#ifndef GMP_WRAPPER_H\n#define GMP_WRAPPER_H\n#include \"mini-gmp.h\"\n#include <stdarg.h>\nstatic inline void mpz_inits(mpz_t x, ...) {\n    va_list ap; va_start(ap, x); mpz_init(x);\n    while ((x = va_arg(ap, mpz_ptr)) != NULL) mpz_init(x);\n    va_end(ap);\n}\nstatic inline void mpz_clears(mpz_t x, ...) {\n    va_list ap; va_start(ap, x); mpz_clear(x);\n    while ((x = va_arg(ap, mpz_ptr)) != NULL) mpz_clear(x);\n    va_end(ap);\n}\n#endif\n"

    downloadRuntime : String -> String -> IO (Either String (String, String))
    downloadRuntime refcSrc miniGmp = do
      putStrLn "        Downloading RefC runtime..."

      -- Download RefC sources
      let refcFiles : List String = ["memoryManagement.c", "runtime.c", "stringOps.c",
                       "mathFunctions.c", "casts.c", "clock.c", "buffer.c",
                       "prim.c", "refc_util.c"]
      let refcHeaders : List String = ["runtime.h", "cBackend.h", "datatypes.h", "_datatypes.h",
                         "refc_util.h", "mathFunctions.h", "memoryManagement.h",
                         "stringOps.h", "casts.h", "clock.h", "buffer.h",
                         "prim.h", "threads.h"]
      let cFiles : List String = ["idris_support.c", "idris_file.c", "idris_directory.c", "idris_util.c"]
      let cHeaders : List String = ["idris_support.h", "idris_file.h", "idris_directory.h", "idris_util.h"]

      _ <- system $ "mkdir -p " ++ refcSrc ++ " " ++ miniGmp

      -- Download refc files
      _ <- traverse_ (\f => system $
        "curl -sLo " ++ refcSrc ++ "/" ++ f ++
        " https://raw.githubusercontent.com/idris-lang/Idris2/main/support/refc/" ++ f)
        (refcFiles ++ refcHeaders)

      -- Download c support files
      _ <- traverse_ (\f => system $
        "curl -sLo " ++ refcSrc ++ "/" ++ f ++
        " https://raw.githubusercontent.com/idris-lang/Idris2/main/support/c/" ++ f)
        (cFiles ++ cHeaders)

      -- Download mini-gmp
      _ <- system $ "curl -sLo " ++ miniGmp ++ "/mini-gmp.c https://gmplib.org/repo/gmp/raw-file/tip/mini-gmp/mini-gmp.c"
      _ <- system $ "curl -sLo " ++ miniGmp ++ "/mini-gmp.h https://gmplib.org/repo/gmp/raw-file/tip/mini-gmp/mini-gmp.h"

      -- Create gmp.h wrapper
      Right _ <- writeFile (miniGmp ++ "/gmp.h") gmpWrapper
        | Left err => pure $ Left $ "Failed to write gmp.h: " ++ show err

      pure $ Right (refcSrc, miniGmp)

||| Step 3: Compile C to WASM using Emscripten
|||
||| @cFile Path to C file from RefC
||| @refcSrc Path to RefC runtime sources
||| @miniGmp Path to mini-gmp
||| @ic0Support Path to IC0 support files (canister_entry.c, etc.)
||| @outputWasm Output WASM path
||| Find FFI header files in a directory (*.h files starting with ic0_ or ic_)
findFfiHeaders : String -> IO (List String)
findFfiHeaders dir = do
  -- Look for project-specific FFI headers using find (more portable than glob)
  (_, output, _) <- executeCommand $ "find " ++ dir ++ " -maxdepth 1 -name 'ic0_*.h' -o -name 'ic_*.h' 2>/dev/null"
  pure $ if null (trim output)
         then []
         else lines (trim output)

public export
compileToWasm : String -> String -> String -> String -> String -> IO (Either String ())
compileToWasm cFile refcSrc miniGmp ic0Support outputWasm = do
  putStrLn "      Step 3: C → WASM (Emscripten)"

  -- RefC source files (minimal set for canister)
  let refcCFiles = unwords $ map (\f => refcSrc ++ "/" ++ f)
        ["runtime.c", "memoryManagement.c", "stringOps.c",
         "mathFunctions.c", "casts.c", "prim.c", "refc_util.c"]

  -- Check for ic_ffi_bridge.c (generic FFI bridge)
  Right _ <- readFile (ic0Support ++ "/ic_ffi_bridge.c")
    | Left _ => compileWithoutBridge cFile refcCFiles miniGmp ic0Support outputWasm

  -- Find project-specific FFI headers to include
  ffiHeaders <- findFfiHeaders ic0Support
  let includeFlags = unwords $ map (\h => "-include " ++ h) ffiHeaders

  let cmd = "CPATH= CPLUS_INCLUDE_PATH= emcc " ++ cFile ++ " " ++
            refcCFiles ++ " " ++
            miniGmp ++ "/mini-gmp.c " ++
            ic0Support ++ "/ic0_stubs.c " ++
            ic0Support ++ "/canister_entry.c " ++
            ic0Support ++ "/wasi_stubs.c " ++
            ic0Support ++ "/ic_ffi_bridge.c " ++
            includeFlags ++ " " ++
            "-I" ++ miniGmp ++ " " ++
            "-I" ++ refcSrc ++ " " ++
            "-I" ++ ic0Support ++ " " ++
            "-o " ++ outputWasm ++ " " ++
            "-s STANDALONE_WASM=1 " ++
            "-s FILESYSTEM=0 " ++
            "-s ERROR_ON_UNDEFINED_SYMBOLS=0 " ++
            "--no-entry " ++
            "-g " ++
            "-gsource-map " ++
            "-O2"

  (exitCode, _, stderr) <- executeCommand cmd

  if exitCode /= 0
    then pure $ Left $ "Emscripten compilation failed: " ++ stderr
    else do
      putStrLn $ "        Output: " ++ outputWasm
      pure $ Right ()
  where
    -- Fallback when ic_ffi_bridge.c doesn't exist (legacy projects)
    compileWithoutBridge : String -> String -> String -> String -> String -> IO (Either String ())
    compileWithoutBridge cFile' refcCFiles' miniGmp' ic0Support' outputWasm' = do
      -- Find project-specific FFI headers
      ffiHeaders <- findFfiHeaders ic0Support'
      let includeFlags = unwords $ map (\h => "-include " ++ h) ffiHeaders

      let cmd = "CPATH= CPLUS_INCLUDE_PATH= emcc " ++ cFile' ++ " " ++
                refcCFiles' ++ " " ++
                miniGmp' ++ "/mini-gmp.c " ++
                ic0Support' ++ "/ic0_stubs.c " ++
                ic0Support' ++ "/canister_entry.c " ++
                ic0Support' ++ "/wasi_stubs.c " ++
                includeFlags ++ " " ++
                "-I" ++ miniGmp' ++ " " ++
                "-I" ++ refcSrc ++ " " ++
                "-I" ++ ic0Support' ++ " " ++
                "-o " ++ outputWasm' ++ " " ++
                "-s STANDALONE_WASM=1 " ++
                "-s FILESYSTEM=0 " ++
                "-s ERROR_ON_UNDEFINED_SYMBOLS=0 " ++
                "--no-entry " ++
                "-g " ++
                "-gsource-map " ++
                "-O2"

      (exitCode, _, stderr) <- executeCommand cmd

      if exitCode /= 0
        then pure $ Left $ "Emscripten compilation failed: " ++ stderr
        else do
          putStrLn $ "        Output: " ++ outputWasm'
          pure $ Right ()

||| Step 4: Stub WASI imports using wabt tools
|||
||| IC doesn't support WASI, so we replace WASI imports with stubs.
||| @inputWasm Input WASM with WASI imports
||| @outputWasm Output WASM with stubs
public export
stubWasi : String -> String -> IO (Either String ())
stubWasi inputWasm outputWasm = do
  putStrLn "      Step 4: WASI stubbing"

  -- Check if wabt tools available
  (code, _, _) <- executeCommand "which wasm2wat wat2wasm python3"
  if code /= 0
    then do
      -- Missing tools, just copy
      putStrLn "        wabt/python3 not found, skipping WASI stub"
      _ <- system $ "cp " ++ inputWasm ++ " " ++ outputWasm
      pure $ Right ()
    else do
      let watFile = inputWasm ++ ".wat"
      let stubbedWat = inputWasm ++ "_stubbed.wat"

      -- Convert to WAT
      (c1, _, e1) <- executeCommand $ "wasm2wat " ++ inputWasm ++ " -o " ++ watFile
      if c1 /= 0
        then pure $ Left $ "wasm2wat failed: " ++ e1
        else do
          -- Use stub_wasi.py script from idris2-wasm/support/tools
          let scriptFile = "/Users/bob/code/idris2-wasm/support/tools/stub_wasi.py"

          (c2, _, e2) <- executeCommand $ "python3 " ++ scriptFile ++ " " ++ watFile ++ " " ++ stubbedWat

          if c2 /= 0
            then do
              putStrLn $ "        Python stubbing failed: " ++ e2 ++ ", using original"
              _ <- system $ "cp " ++ inputWasm ++ " " ++ outputWasm
              pure $ Right ()
            else do
              -- Convert back to WASM
              (c3, _, e3) <- executeCommand $ "wat2wasm " ++ stubbedWat ++ " -o " ++ outputWasm
              _ <- system $ "rm -f " ++ watFile ++ " " ++ stubbedWat

              if c3 /= 0
                then do
                  putStrLn $ "        wat2wasm failed: " ++ e3 ++ ", using original"
                  _ <- system $ "cp " ++ inputWasm ++ " " ++ outputWasm
                  pure $ Right ()
                else do
                  -- Verify no WASI imports remain
                  (_, wasiCheck, _) <- executeCommand $ "wasm2wat " ++ outputWasm ++ " 2>/dev/null | grep -c wasi_snapshot_preview1 || echo 0"
                  putStrLn $ "        WASI imports stubbed (remaining: " ++ trim wasiCheck ++ ")"
                  pure $ Right ()

-- =============================================================================
-- Main Build Function
-- =============================================================================

||| Build complete canister WASM from Idris2 source
|||
||| @opts Build options
||| @ic0Support Path to IC0 support files directory
||| Returns path to final stubbed WASM on success
public export
buildCanister : BuildOptions -> String -> IO BuildResult
buildCanister opts ic0Support = do
  putStrLn "    Building WASM (Idris2 → RefC → Emscripten)..."

  let buildDir = opts.projectDir ++ "/build/idris"
  let wasmDir = opts.projectDir ++ "/build"
  let rawWasm = wasmDir ++ "/" ++ opts.canisterName ++ ".wasm"
  let stubbedWasm = wasmDir ++ "/" ++ opts.canisterName ++ "_stubbed.wasm"

  -- Step 1: Idris2 → C
  Right cFile <- compileToRefC opts buildDir
    | Left err => pure $ BuildError err

  -- Step 2: Prepare runtime
  Right (refcSrc, miniGmp) <- prepareRefCRuntime
    | Left err => pure $ BuildError err

  -- Step 3: C → WASM
  Right () <- compileToWasm cFile refcSrc miniGmp ic0Support rawWasm
    | Left err => pure $ BuildError err

  -- Step 4: Stub WASI
  Right () <- stubWasi rawWasm stubbedWasm
    | Left err => pure $ BuildError err

  -- Step 5: Generate Source Maps (if enabled)
  when opts.generateSourceMap $ do
    putStrLn "      Step 5: Generating Source Maps"
    Right cContent <- readFile cFile
      | Left _ => putStrLn "        Warning: Could not read C file for source map"
    let idrisCMap = generateIdrisCSourceMapWithFunctions cFile cContent
    let idrisCMapPath = wasmDir ++ "/idris2-c.map"
    Right () <- writeSourceMap idrisCMapPath idrisCMap
      | Left _ => putStrLn "        Warning: Could not write idris2-c.map"
    putStrLn $ "        Generated: " ++ idrisCMapPath
    putStrLn $ "        Sources: " ++ show (length idrisCMap.sources) ++ " Idris files"
    putStrLn $ "        Functions: " ++ show (length idrisCMap.names) ++ " Idris functions"

  putStrLn $ "    Build complete: " ++ stubbedWasm
  pure $ BuildSuccess stubbedWasm

||| Build canister using project's lib/ic0 for support files
|||
||| @opts Build options
||| Returns path to final stubbed WASM on success
public export
buildCanisterAuto : BuildOptions -> IO BuildResult
buildCanisterAuto opts = do
  -- Try to find IC0 support in project or sibling
  let projectIc0 = opts.projectDir ++ "/lib/ic0"
  let siblingIc0 = opts.projectDir ++ "/../idris2-wasm/support/ic0"

  Right _ <- readFile (projectIc0 ++ "/canister_entry.c")
    | Left _ => do
        Right _ <- readFile (siblingIc0 ++ "/canister_entry.c")
          | Left _ => pure $ BuildError "IC0 support files not found in lib/ic0 or ../idris2-wasm/support/ic0"
        buildCanister opts siblingIc0

  buildCanister opts projectIc0
